# -*- coding: utf-8 -*-
"""Regional Clustering with SOM

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d43VBk2Y4By6r8zUZy5Lm_CeXvQFT4Wu
"""

import numpy as np
import pandas as pd
import sklearn
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

class SOM_Clustering:
  def __init__(self):
    self.cluster = 0
    self.n = 38
    self.m = 9
    self.p = 0
    self.i = 0

    self.dt = np.zeros((self.n,self.m))
    self.data = np.zeros((self.n,self.m))
    self.dtmin = np.zeros(self.m)
    self.dtmax = np.zeros(self.m)
    self.l_rate = np.zeros(100)
    self.sigma = None
    self.nilai_terkecil = 0
    self.cls = np.zeros(self.n, dtype=int)

  def load_data(self):
    self.data = pd.read_csv('datajst.csv', delimiter=';', decimal=',')
    print("Data yang digunakan : \n")
    print(self.data.head())

  def normalize_data(self):
    for m in range(self.m):
        self.dtmin[m] = np.min(self.data.iloc[:,m])
        self.dtmax[m] = np.max(self.data.iloc[:,m])

        print(f"\ndata min dari kolom ke-{m+1} adalah {self.dtmin[m]:.2f}")
        print(f"data max dari kolom ke-{m+1} adalah {self.dtmax[m]:.2f}\n")

    print("\nData Normalisasi : \n")
    for n in range(self.n):
      for m in range(self.m):
        self.dt[n,m] = ((0.8 * (self.data.iloc[n,m] - self.dtmin[m])) / (self.dtmax[m] - self.dtmin[m])) + 0.1
        print(f"{self.dt[n,m]:.4f} ", end="")
      print()

  def input_cl_lr(self):
    self.cluster = int(input("\nJumlah cluster: "))
    self.l_rate = float(input("Nilai learning rate: "))

  def initialize_weights(self):
    self.w = np.zeros((self.cluster,self.m))

    print("\nBobot Awal (W) : ")
    for p in range(self.cluster):
      for m in range(self.m):
        self.w[p,m] = np.random.rand()
        print(f"{self.w[p,m]:.5f} ", end="")
      print()

  def iteration(self, max_epoch=1000):
      same_cluster_count = 0
      prev_cls = np.zeros_like(self.cls)

      for epoch in range(max_epoch):
          print(f"\nIterasi ke-{epoch+1} : ")
          if epoch > 0:
              self.l_rate *= 0.5

          print(f"Learning Rate: {self.l_rate:.5f}\n")
          prev_cls = self.cls.copy()

          for n in range(self.n):
              print(f"Data ke-{n+1} : ")
              print()

              distances = np.linalg.norm(self.w - self.dt[n, :], axis=1)
              for c in range(self.cluster):
                print(f"D({c + 1}) : {distances[c]:.5f}")
              self.cls[n] = np.argmin(distances)
              print(f"\nNilai D(j) terkecil adalah {distances[self.cls[n]]:.5f}, yaitu pada D({self.cls[n] + 1})")

              winner = self.cls[n]
              self.w[winner, :] += self.l_rate * (self.dt[n, :] - self.w[winner, :])

              print(f"Update Bobot untuk Cluster {winner + 1}: {self.w[winner, :]}")

          if np.array_equal(prev_cls, self.cls):
              same_cluster_count += 1
          else:
              same_cluster_count = 0

          if same_cluster_count >= 2:
              print("Cluster Sama, Iterasi Berhenti")
              break

      print("\nBobot Optimal:")
      for p in range(self.cluster):
          for m in range(self.m):
              print(f"{self.w[p, m]:.5f} ", end="")
          print()

      print("\nFinal Cluster : ")
      for c in range(self.cluster):
          print(f"\nCluster {c + 1}:")
          members = [i + 1 for i in range(self.n) if self.cls[i] == c]
          print(f"Data : {members}")

  def visualize_clusters(self):
    pca = PCA(n_components=2)
    reduced_data = pca.fit_transform(self.dt)

    plt.figure(figsize=(8, 6))

    for c in range(self.cluster):
        cluster_points = reduced_data[self.cls == c]
        plt.scatter(cluster_points[:, 0], cluster_points[:, 1], label=f"Cluster {c+1}")

    for p in range(self.cluster):
        plt.scatter(self.w[p, 0], self.w[p, 1], s=200, c='black', marker='X')

    plt.title("Cluster Visualization")
    plt.legend()
    plt.show()



def main():
  SOM = SOM_Clustering()
  SOM.load_data()
  SOM.normalize_data()
  SOM.input_cl_lr()
  SOM.initialize_weights()
  SOM.iteration()
  SOM.visualize_clusters()

if __name__ == "__main__":
    main()